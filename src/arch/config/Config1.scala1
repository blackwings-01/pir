package pir.plasticine.config
                          
import pir.plasticine.graph._
import scala.language.implicitConversions
import scala.language.reflectiveCalls
import scala.collection.mutable.ListBuffer
import scala.reflect.runtime.universe._

// Assuming scalar buffer are before and after pipeline stages
object Config1 extends Spade {
  override def toString = "Plasticine_Config1"

  // Assume all CUs are homogenous for now

   // Inner CU Specs
  override val wordWidth = 32
  override val numLanes = 4
  
  private val numRCUs = 4
  private val numTTs = 2 
  private val numArgIns = numLanes // per bus
  private val numArgOuts = numLanes // per bus 

  private val numArgInBuses = 1 
  private val numArgOutBuses = 1 

  val argInBuses = List.fill(numArgInBuses) { OutBus(numLanes) }
  val argOutBuses = List.fill (numArgOutBuses) { InBus(numLanes) }
  val argIns = List.tabulate(numArgInBuses, numArgIns) { case (ib, ia) =>
    ScalarOut(argInBuses(ib).inports(ia))
  }.flatten
  val argOuts = List.tabulate(numArgOutBuses, numArgOuts) { case (ib, ia) =>
    ScalarIn(argOutBuses(ib).outports(ia))
  }.flatten
  override val top = Top(argIns, argOuts, argInBuses, argOutBuses)

  def genFields[T](numPRs:Int, numCtrs:Int, numSRAMs:Int, numScalarOuts:Int)(implicit cltp:TypeTag[T]) = {
    val numBusIns = if (numSRAMs==0) 1 else numSRAMs
    val numScalarIns = numLanes // Number of scalarIn per InBus 

    // Create Pipeline Regs (entire row of physicall register for all stages)
    // No overlapping between mappings
    val regs = List.tabulate(numPRs) { ir => Reg() }
    var ptr = 0

    val vecIns = List.tabulate(numBusIns) { is =>
      val ib = InBus(numLanes)
      regs(ptr + is) <-- ib // Map logical register to InBus
      ib
    }
    val vecOut = {
      val ob = OutBus(numLanes)
      regs(ptr) <-- ob
      ob
    } 
    val scalarIns = List.tabulate(numBusIns, vecIns.head.outports.size) { case (ib, is) => 
      val si = ScalarIn(vecIns(ib).outports(is))
      regs(ptr + is) <-- si
      si
    }.flatten
    val scalarOuts = List.tabulate(vecOut.inports.size) { is =>
      val so = typeOf[T] match {
        case t if t =:= typeOf[ComputeUnit] => ScalarOut(vecOut.inports(is))
        case t if t =:= typeOf[TileTransfer] => AddrOut()
      }
      regs(ptr + is) <-- so
      so
    }
    val ctrs = List.tabulate(numCtrs) { ic => 
      val c = Counter() 
      val sis = scalarIns.map(_.out)
      c.min <== sis :+ Const
      c.max <== sis :+ Const
      c.step <== sis :+ Const
      regs(ptr + ic) <-- c.out
      c
    }
    /* Chain counters together */
    for (i <- 1 until numCtrs) {
      ctrs(i).en <== ctrs(i-1).sat
    } 
    for (i <- 0 until numCtrs by 2) {
      ctrs(i).en <== top.clk
    }
    ptr += numCtrs

    val srams = List.tabulate(numSRAMs) { is => 
      val s = SRAM()
      s.readAddr <== ctrs.map(_.out)
      s.writeAddr <== ctrs.map(_.out)
      regs(ptr + is) <-- List[RMPort](s.readAddr, s.writeAddr) 
      s
    } 
    ptr += numSRAMs
    srams.zipWithIndex.foreach { case (s,is) =>
      s.writePort <== vecIns(is).outports(0)
      regs(ptr + is) <-- List[RMPort](s.writePort, s.readPort)
    }
    ptr += numSRAMs

    /* Pipeline Stages ( Describing configurable connections of operands and result of the FU in
     * that stage ) */
    val etstage = EmptyStage(regs)
    val wastages:List[WAStage] = List.fill(3) { WAStage(numOprds=2, regs) } // Write addr calculation stages
    val rastages:List[FUStage] = List.fill(3) { FUStage(numOprds=2, regs) } // Read addr calculation stages 
    val regstages:List[FUStage] = List.fill(3) { FUStage(numOprds=1, regs) } // Regular stages
    val redstages:List[ReduceStage] = List.fill(4) { ReduceStage(numOprds=2, regs) } // Reduction stage 

    val fustages:List[FUStage] = wastages ++ rastages ++ regstages ++ redstages 
    val stages:List[Stage] = etstage :: fustages 

    fustages.zipWithIndex.foreach { case (stage, i) =>
      val preStage = stages(i-1)
      stage.fu.operands.foreach{ oprd =>
        regs.foreach{ reg =>
          // All stage can read from any regs of its own stage and Const, and  have forwarding 
          // path from its previous stage
          oprd <== stage.prs(reg)
          oprd <== preStage.prs(reg)
        }
        oprd <== Const
      }
      // All stage can write to all regs of its stage
      regs.foreach{ reg => stage.prs(reg) <== stage.fu.out }
    }

    // Stages where srams, ctrs, scalarIn, vecIn can be forwarded to
    val fwstages:List[FUStage] = wastages ++ rastages :+ regstages.head

    // Stages where srams, ctrs, vins, vouts can be forwarded to
    fwstages.foreach { stage =>
      // Creating forwarding path to all operands of the FUs in these stages  
      stage.fu.operands.foreach { oprd =>
        vecIns.foreach{ oprd <== _.viport }
        scalarIns.foreach{ oprd <== _.out }
        ctrs.foreach{ oprd <== _.out }
        srams.foreach{ oprd <== _.readPort }
      }
    }
    // Connections in last stage
    vecOut <== fustages.last.fu.out
    scalarOuts.foreach { _.in <== fustages.last.fu.out }
    srams.foreach { _.writePort <== fustages.last.fu.out }

    (regs, srams, ctrs, scalarIns, scalarOuts, vecIns, vecOut, stages, ptr)
  }

  override val rcus = List.tabulate(numRCUs) { i =>
    val numPRs = 20
    val numCtrs = 10
    val numSRAMs = 2
    val numScalarOuts = numLanes

    val (regs, srams, ctrs, scalarIns, scalarOuts, vecIns, vecOut, stages, ptr) =
      genFields[ComputeUnit](numPRs, numCtrs, numSRAMs, numScalarOuts)
    val c = ComputeUnit(regs, srams, ctrs, scalarIns, scalarOuts, vecIns, vecOut, stages)
    regs(ptr) <-- c.reduce
    c
  } 

  override val ttcus = List.tabulate(numTTs) { i =>
    val numPRs = 15
    val numCtrs = 10
    val numSRAMs = 0
    val numScalarOuts = 1

    val (regs, srams, ctrs, scalarIns, scalarOuts, vecIns, vecOut, stages, ptr) =
      genFields[TileTransfer](numPRs, numCtrs, numSRAMs, numScalarOuts)
    val c = TileTransfer(regs, srams, ctrs, scalarIns, scalarOuts, vecIns, vecOut, stages)
    regs(ptr) <-- c.reduce
    c
  }
  
  /* Network Constrain */ 
  rcus(0).vins(0) <== ttcus(0).vout 
  rcus(0).vins(1) <== ttcus(1).vout
  rcus(1).vins(0) <== ttcus(0).vout 
  rcus(1).vins(1) <== ttcus(1).vout
  rcus(2).vins(0) <== rcus(0).vout 
  rcus(2).vins(1) <== rcus(1).vout
  rcus(3).vins(0) <== rcus(0).vout 
  rcus(3).vins(1) <== rcus(1).vout

  /* Connnect all ArgIns to scalarIns of all CUs and all ArgOuts to scalarOuts of all CUs*/
  (rcus ++ ttcus).foreach { cu =>
    top.vouts.foreach { aib =>
      cu.vins.foreach { vin =>
        vin <== aib
      }
    }
    top.vins.foreach { aob => 
      aob <== cu.vout
    }
  }

}
